---
title: "What is a Service?"
description: "Turn any Git repo (or folder in a monorepo) into a build-and-deploy unit on PlantonCloud."
icon: guide
order: 2
---

# What is a Service?

<Cards columns={3}>
  <Card title="Connect your repo">
    Point PlantonCloud at a GitHub/GitLab repository. We create a webhook and watch your default branch (or a branch you choose).
  </Card>
  <Card title="Trigger pipelines smartly">
    Define a project root and optional trigger paths so pipelines run only when relevant files change. Perfect for monorepos.
  </Card>
  <Card title="Build → (Optionally) Deploy">
    Use platform pipelines (Buildpacks or Dockerfile) or your own Tekton pipeline. Enable PR deployments for previews.
  </Card>
</Cards>

<Callout type="tip" title="End‑user perspective">
  A Service is your deployable unit. It maps a repo (or subfolder) to predictable pipelines and, if enabled, a public/private ingress URL.
</Callout>

## How it works (at a glance)
1. You connect your Git org and pick a repository.
2. You set a `project_root` (optional) and configure `trigger_paths` (optional).
3. You choose who owns pipelines: **Platform** (zero‑config) or **Self‑managed** (Tekton in your repo).
4. On every matching commit, PlantonCloud runs a pipeline. It builds a container image and can deploy it automatically.
5. If ingress is enabled, your service is reachable at a hostname under a chosen DNS domain.

<Callout type="note" title="Multiple Services per repo">
  Monorepo? Create one Service per deployable unit by using a different `project_root` (and optional `trigger_paths`) for each.
</Callout>

## Map your repository

<Cards>
  <Card title="Repository & branch">
    We store the provider (GitHub/GitLab), owner, repo name, browser/clone URLs, and default branch. A webhook is created so commits and PRs can trigger pipelines.
  </Card>
  <Card title="Project root">
    The directory inside your repo that contains this service. Leave empty if your service lives at the repo root.
  </Card>
</Cards>

### Trigger paths (optional but powerful)
Use glob/regex patterns so a pipeline runs only when relevant files change. These are evaluated in addition to the default rule “any change under `project_root/` triggers a pipeline.”

```yaml
# Examples
triggerPaths:
  - services/payments/**           # all changes under a subservice
  - infra/**                       # infra-only changes
  - .github/workflows/**           # when CI config changes

# Trigger on every commit anywhere in the repo:
triggerPaths:
  - "**/*"
```

<Callout type="tip" title="Sparse checkout for monorepos">
  Speed up clones by fetching only specific directories:
  
  ```yaml
  sparseCheckoutDirectories:
    - services/payments
    - libs/common
  ```
  
  This is especially useful when a service references shared code from elsewhere in the repo.
</Callout>

## Pipelines: choose your ownership

<Tabs>
  <Tab label="Platform-managed">
    PlantonCloud provides the pipeline so you don’t maintain Tekton files.

  <ul>
    <li><strong>Buildpacks</strong>: Auto-detects language and builds without a <code>Dockerfile</code>.</li>
    <li><strong>Dockerfile</strong>: We build using the <code>Dockerfile</code> under your <code>project_root</code>.</li>
  </ul>

  <Callout type="note" title="Good defaults">
    This path is great when you want fast, consistent builds without maintaining pipeline manifests.
  </Callout>
  </Tab>
  <Tab label="Self-managed (Tekton)">
    You keep your pipeline in the repo as Tekton YAML. Tell the Service where to find it.

  <ul>
    <li>Put your file at <code>.planton/pipeline.yaml</code> (default), or</li>
    <li>Set <code>tektonPipelineYamlDirectory</code> to the directory that contains <code>pipeline.yaml</code>.</li>
  </ul>

```yaml
pipelineConfiguration:
  pipelineProvider: self
  tektonPipelineYamlDirectory: .planton   # looks for .planton/pipeline.yaml
  params:
    some-key: some-value
```

  <Callout type="warning" title="Filename & default">
    The expected file name is `pipeline.yaml`. If no directory is provided, PlantonCloud looks for `.planton/pipeline.yaml`.
  </Callout>
  </Tab>
</Tabs>

### Deploy toggles
- **Disable pipelines**: Never create new pipelines (useful during migrations or freezes).
- **Disable deployments**: Build the image but skip deploy steps.
- **Enable PR deployments**: Spin up preview environments for pull requests.
- **Pipeline branch**: Allow pipelines only for a specific branch (applies to pushes and PRs).

## Image repository path (the important one)
This field tells the platform where to push images (without the registry host and without the tag). The final image is composed as:

```text
<registryHost>/<image_repository_path>:<gitCommitSha>
```

- The registry host comes from your environment (e.g., ECR or Artifact Registry).
- The tag is always the triggering commit SHA for immutability and traceability.

Examples of valid `image_repository_path` values:

```text
backend-api
acmecorp/backend-api
github.com/acmecorp/backend-api
github.com/acmecorp/monorepo/services/backend-api
```

<Callout type="tip" title="Do & Don’t">
  <ul>
    <li>Do keep it stable across builds of the same service.</li>
    <li>Do nest paths for clarity in multi-team orgs, e.g., <code>acmecorp/payments/api</code>.</li>
    <li>Don’t include the registry host or tag; those are added automatically.</li>
  </ul>
</Callout>

## Ingress (optional)
Enable ingress to expose the service via HTTP(S). Choose a DNS domain managed by your org; PlantonCloud provisions the right resources for the target runtime platform.

## Monorepo recipes

<Cards columns={2}>
  <Card title="One repo → many Services">
    Create one Service per deployable unit using distinct `project_root` values (and targeted `trigger_paths`).
  </Card>
  <Card title="Shared libraries">
    Use `sparseCheckoutDirectories` to pull both the service and any shared `libs/**` folders it imports.
  </Card>
  <Card title="Selective triggers">
    Combine `project_root` with `trigger_paths` to avoid noisy builds when unrelated areas change.
  </Card>
  <Card title="Self-managed pipelines">
    Keep Tekton in `.planton/pipeline.yaml` per service folder; set `tektonPipelineYamlDirectory` accordingly.
  </Card>
</Cards>

## Example Service (YAML)
```yaml
apiVersion: service-hub.planton.cloud/v1
kind: Service
metadata:
  name: backend-api
  org: acmecorp
spec:
  description: Backend API service
  gitRepo:
    ownerName: acmecorp
    name: platform-monorepo
    defaultBranch: main
    browserUrl: https://github.com/acmecorp/platform-monorepo
    cloneUrl: https://github.com/acmecorp/platform-monorepo.git
    gitRepoProvider: github
    projectRoot: services/backend-api
    triggerPaths:
      - services/backend-api/**
    sparseCheckoutDirectories:
      - services/backend-api
      - libs/common
  pipelineConfiguration:
    pipelineProvider: platform      # or: self
    imageBuildMethod: buildpacks    # or: dockerfile
    imageRepositoryPath: acmecorp/backend-api
    enablePullRequestDeployments: true
    pipelineBranch: main
  ingress:
    enabled: true
    dnsDomainId: dns_01exampleid
```

## FAQ
- Can I connect the same repo to multiple Services?
  - Yes. Use different `project_root` (and optionally different `trigger_paths`).
- Do I need a `Dockerfile`?
  - Only if you choose the Dockerfile build method. Buildpacks require no Dockerfile.
- Where does PlantonCloud look for my self-managed pipeline?
  - By default at `.planton/pipeline.yaml`. Set `tektonPipelineYamlDirectory` to point to the folder containing `pipeline.yaml` if you keep it elsewhere.
- How do PR deployments work?
  - Enable the toggle. PRs to the configured `pipeline_branch` will build and deploy preview environments.

## See also
- Service spec: `planton-cloud/apis/cloud/planton/apis/servicehub/service/v1/spec.proto`
- Enums: `planton-cloud/apis/cloud/planton/apis/servicehub/service/v1/enum.proto`
- Default Tekton file location: `backend/services/temporal-worker/.../ServicePipelineTektonProperties.java`
- Example service YAML: `ops/planton-cloud/service-hub/services/service-hub.yaml`

